"""
Minimal LLMPL → Python proof-of-concept compiler.

Currently supported subset:
  * Single `main` function with the standard signature
  * `declare variable NAME [as TYPE] with value EXPR`
  * `set NAME to EXPR`
  * `call print_line(EXPR)`
  * `if CONDITION then:` / `else:` / `end if`
  * `return success with value EXPR`

Expressions (`EXPR`) may be:
  * String literals enclosed in double quotes
  * Integer literals
  * Boolean literals (`true`, `false`)
  * Identifiers
  * Unary `not`
  * Binary operators:
      - `concatenated with` (string concatenation)
      - `plus`, `minus`, `times`, `divided by`, `modulo`
      - Comparisons (`is equal to`, `is not equal to`, `is greater than`,
        `is less than`, `is greater than or equal to`, `is less than or equal to`)
      - Boolean connectives (`and`, `or`)

This MVP focuses on validating grammar structure and emitting a runnable Python
artifact without covering the entire LLMPL specification.
"""

from __future__ import annotations

import argparse
import pathlib
import re
import sys
from dataclasses import dataclass
from typing import Iterable, List


MAIN_SIGNATURE = (
    'define function main taking argv as List of String returning Result of Integer or String'
)


class CompilationError(RuntimeError):
    """Raised when the MVP compiler encounters unsupported constructs."""


def strip_comments(lines: Iterable[str]) -> List[str]:
    cleaned: List[str] = []
    for line in lines:
        stripped = line.rstrip("\n")
        comment_index = stripped.find("//")
        if comment_index != -1:
            stripped = stripped[:comment_index]
        cleaned.append(stripped.rstrip())
    return cleaned


def compile_to_python(source: str) -> str:
    lines = strip_comments(source.splitlines())
    function_defs = _parse_functions(lines)

    python_lines: List[str] = ['"""Generated by llmpl_to_python MVP"""', "import sys", ""]

    for fn in function_defs:
        python_lines.extend(_emit_function(fn))
        python_lines.append("")

    python_lines.extend(
        [
            'if __name__ == "__main__":',
            "    raise SystemExit(main(sys.argv))",
        ]
    )
    return "\n".join(python_lines).rstrip() + "\n"


_IDENTIFIER_RE = re.compile(r"^[A-Za-z_][A-Za-z0-9_]*$")


_BINARY_OPERATORS = [
    (" and ", " and ", "bool"),
    (" or ", " or ", "bool"),
    (" is greater than or equal to ", " >= ", "compare"),
    (" is less than or equal to ", " <= ", "compare"),
    (" is greater than ", " > ", "compare"),
    (" is less than ", " < ", "compare"),
    (" is not equal to ", " != ", "compare"),
    (" is equal to ", " == ", "compare"),
    (" concatenated with ", " + ", "concat"),
    (" plus ", " + ", "arith"),
    (" minus ", " - ", "arith"),
    (" times ", " * ", "arith"),
    (" divided by ", " / ", "arith"),
    (" modulo ", " % ", "arith"),
]


@dataclass
class FunctionDef:
    name: str
    params: List[str]
    body: List[str]
    is_main: bool


def _parse_functions(lines: List[str]) -> List[FunctionDef]:
    functions: List[FunctionDef] = []
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        if not line:
            i += 1
            continue
        if not line.startswith("define function "):
            i += 1
            continue

        signature = line
        i += 1
        while i < len(lines) and not lines[i].strip():
            i += 1
        if i >= len(lines) or lines[i].strip() != "function body:":
            raise CompilationError("Expected 'function body:' after function signature.")
        i += 1

        body: List[str] = []
        while i < len(lines):
            stripped = lines[i].strip()
            if stripped == "end function":
                break
            body.append(stripped)
            i += 1
        else:
            raise CompilationError("Function missing terminating 'end function'.")

        functions.append(_parse_function_signature(signature, body))
        i += 1

    if not any(fn.is_main for fn in functions):
        raise CompilationError("No main function found in source.")
    return functions


def _parse_function_signature(signature: str, body: List[str]) -> FunctionDef:
    if signature == MAIN_SIGNATURE:
        return FunctionDef(name="main", params=["argv"], body=body, is_main=True)

    match = re.match(
        r"^define function (?P<name>[A-Za-z_][A-Za-z0-9_]*) taking (?P<params>.+) returning (?P<ret>.+)$",
        signature,
    )
    if not match:
        raise CompilationError(f"Unsupported function signature: {signature}")

    name = match.group("name")
    params_section = match.group("params").strip()
    params: List[str] = []
    if params_section.lower() not in {"no parameters", "nothing"}:
        raw_params = [p.strip() for p in params_section.split(" and ")]
        for param in raw_params:
            if " as " not in param:
                raise CompilationError(f"Parameter missing type declaration: {param}")
            param_name = param.split(" as ", 1)[0].strip()
            if not _IDENTIFIER_RE.match(param_name):
                raise CompilationError(f"Invalid parameter name: {param_name}")
            params.append(param_name)

    return FunctionDef(name=name, params=params, body=body, is_main=False)


def _emit_function(fn: FunctionDef) -> List[str]:
    header_params = ", ".join(fn.params)
    lines = [f"def {fn.name}({header_params}):"]
    body_lines = translate_statements(fn.body, indent_level=1)
    if not body_lines:
        body_lines = ["    pass"]
    lines.extend(body_lines)
    return lines


def translate_statements(body: List[str], indent_level: int) -> List[str]:
    python_lines: List[str] = []
    indent_unit = "    "
    level = indent_level
    start_level = indent_level

    for raw in body:
        line = raw.strip()
        if not line:
            continue

        if line == "end if":
            level -= 1
            if level < start_level:
                raise CompilationError("Unexpected 'end if' without matching 'if'.")
            continue

        if line == "else:":
            if level <= start_level:
                raise CompilationError("Unexpected 'else' without matching 'if'.")
            level -= 1
            current_indent = indent_unit * level
            python_lines.append(f"{current_indent}else:")
            level += 1
            continue

        current_indent = indent_unit * level

        if line.startswith("declare variable "):
            python_lines.append(_translate_declare(line, current_indent))
            continue

        if line.startswith("set "):
            python_lines.append(_translate_assignment(line, current_indent))
            continue

        if line.startswith("call "):
            call_target = line[len("call ") :]
            if call_target.startswith("print_line(") and call_target.endswith(")"):
                inner = call_target[len("print_line(") : -1]
                expr_py = translate_expr(inner)
                python_lines.append(f"{current_indent}print({expr_py})")
            else:
                call_expr = translate_expr(call_target)
                python_lines.append(f"{current_indent}{call_expr}")
            continue

        if line.startswith("return success with value"):
            value = line[len("return success with value") :].strip()
            if not value:
                raise CompilationError("Return success must specify a value.")
            python_lines.append(f"{current_indent}return {translate_expr(value)}")
            continue

        if line.startswith("if ") and line.endswith(" then:"):
            condition = line[len("if ") : -len(" then:")]
            cond_py = translate_expr(condition)
            python_lines.append(f"{current_indent}if {cond_py}:")
            level += 1
            continue

        raise CompilationError(f"Unsupported statement: {line}")

    if level != start_level:
        raise CompilationError("Unbalanced control flow blocks detected.")

    return python_lines


def _translate_declare(line: str, indent: str) -> str:
    prefix = "declare variable "
    rest = line[len(prefix) :]
    if " with value " not in rest:
        raise CompilationError("declare variable must include 'with value'.")
    lhs, expr_src = rest.split(" with value ", 1)
    lhs = lhs.strip()
    expr_py = translate_expr(expr_src)
    if " as " in lhs:
        name = lhs.split(" as ", 1)[0].strip()
    else:
        name = lhs
    if not _IDENTIFIER_RE.match(name):
        raise CompilationError(f"Unsupported identifier in declaration: {name}")
    return f"{indent}{name} = {expr_py}"


def _translate_assignment(line: str, indent: str) -> str:
    prefix = "set "
    rest = line[len(prefix) :]
    if " to " not in rest:
        raise CompilationError("set statement must include 'to'.")
    name, expr_src = rest.split(" to ", 1)
    name = name.strip()
    if not _IDENTIFIER_RE.match(name):
        raise CompilationError(f"Unsupported identifier in assignment: {name}")
    return f"{indent}{name} = {translate_expr(expr_src)}"


def _split_on_keyword(expr: str, keyword: str) -> tuple[str, str] | None:
    idx = expr.find(keyword)
    while idx != -1:
        if keyword == " or " and expr[idx:].startswith(" or equal to "):
            idx = expr.find(keyword, idx + len(keyword))
            continue
        left = expr[:idx].strip()
        right = expr[idx + len(keyword) :].strip()
        if not left or not right:
            idx = expr.find(keyword, idx + len(keyword))
            continue
        return left, right
    return None


def translate_expr(expr: str) -> str:
    expr = expr.strip()
    if not expr:
        raise CompilationError("Empty expression.")

    if expr.startswith('"') and expr.endswith('"'):
        content = expr[1:-1]
        return repr(content)

    if expr.isdigit() or (expr.startswith("-") and expr[1:].isdigit()):
        return expr

    lowered = expr.lower()
    if lowered == "true":
        return "True"
    if lowered == "false":
        return "False"

    if lowered.startswith("not "):
        inner = expr[4:]
        return f"(not {translate_expr(inner)})"

    if "(" in expr and expr.endswith(")"):
        name_part, remainder = expr.split("(", 1)
        func_name = name_part.strip()
        if func_name and _IDENTIFIER_RE.match(func_name):
            args_text = remainder[:-1].strip()
            args = _split_arguments(args_text)
            arg_exprs = [translate_expr(arg) for arg in args]
            return f"{func_name}({', '.join(arg_exprs)})"

    for keyword, operator, kind in _BINARY_OPERATORS:
        split_result = _split_on_keyword(expr, keyword)
        if split_result is not None:
            left, right = split_result
            left_py = translate_expr(left)
            right_py = translate_expr(right)
            if kind == "concat":
                return f"(str({left_py}){operator}str({right_py}))"
            return f"({left_py}{operator}{right_py})"

    if _IDENTIFIER_RE.match(expr):
        return expr

    raise CompilationError(f"Unsupported expression: {expr}")


def _split_arguments(args_text: str) -> List[str]:
    if not args_text:
        return []
    parts = [part.strip() for part in args_text.split(",")]
    if any(not part for part in parts):
        raise CompilationError("Empty argument in call expression.")
    return parts


def parse_args(argv: List[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="LLMPL → Python MVP compiler.")
    parser.add_argument("source", type=pathlib.Path, help="Input .llmpl file")
    parser.add_argument(
        "--emit",
        type=pathlib.Path,
        help="Path to write generated Python. Defaults to stdout.",
    )
    parser.add_argument(
        "--run",
        action="store_true",
        help="Execute the generated Python immediately.",
    )
    return parser.parse_args(argv)


def main(argv: List[str]) -> int:
    args = parse_args(argv)
    source_text = args.source.read_text(encoding="utf-8")
    generated = compile_to_python(source_text)

    if args.emit:
        args.emit.write_text(generated, encoding="utf-8")
    else:
        sys.stdout.write(generated)

    if args.run:
        namespace: dict[str, object] = {"sys": sys}
        exec(generated, namespace)  # noqa: S102 - intentional for MVP
        result = namespace["main"]([str(args.source)])
        return int(result if isinstance(result, int) else 0)

    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
